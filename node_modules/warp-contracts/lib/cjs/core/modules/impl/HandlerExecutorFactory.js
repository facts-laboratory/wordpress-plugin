"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlerExecutorFactory = exports.ContractError = void 0;
const rust_wasm_imports_1 = require("./wasm/rust-wasm-imports");
const vm2 = __importStar(require("vm2"));
const smartweave_global_1 = require("../../../legacy/smartweave-global");
const Benchmark_1 = require("../../../logging/Benchmark");
const LoggerFactory_1 = require("../../../logging/LoggerFactory");
const JsHandlerApi_1 = require("./handler/JsHandlerApi");
const WasmHandlerApi_1 = require("./handler/WasmHandlerApi");
const normalize_source_1 = require("./normalize-source");
const MemCache_1 = require("../../../cache/impl/MemCache");
const utils_1 = require("../../../utils/utils");
const warp_isomorphic_1 = require("warp-isomorphic");
// 'require' to fix esbuild adding same lib in both cjs and esm format
// https://github.com/evanw/esbuild/issues/1950
// eslint-disable-next-line
const BigNumber = require('bignumber.js');
class ContractError extends Error {
    constructor(message, subtype) {
        super(message);
        this.subtype = subtype;
        this.name = 'ContractError';
    }
}
exports.ContractError = ContractError;
/**
 * A factory that produces handlers that are compatible with the "current" style of
 * writing SW contracts (i.e. using "handle" function).
 */
class HandlerExecutorFactory {
    constructor(arweave) {
        this.arweave = arweave;
        this.logger = LoggerFactory_1.LoggerFactory.INST.create('HandlerExecutorFactory');
        // TODO: cache compiled wasm binaries here.
        this.cache = new MemCache_1.MemCache();
    }
    async create(contractDefinition, evaluationOptions, warp) {
        let kvStorage = null;
        if (evaluationOptions.useKVStorage) {
            kvStorage = warp.kvStorageFactory(contractDefinition.txId);
        }
        const swGlobal = new smartweave_global_1.SmartWeaveGlobal(this.arweave, {
            id: contractDefinition.txId,
            owner: contractDefinition.owner
        }, evaluationOptions, kvStorage);
        const extensionPlugins = warp.matchPlugins(`^smartweave-extension-`);
        extensionPlugins.forEach((ex) => {
            const extension = warp.loadPlugin(ex);
            extension.process(swGlobal.extensions);
        });
        if (contractDefinition.contractType == 'wasm') {
            this.logger.info('Creating handler for wasm contract', contractDefinition.txId);
            const benchmark = Benchmark_1.Benchmark.measure();
            let wasmInstance;
            let jsExports = null;
            const wasmResponse = generateResponse(contractDefinition.srcBinary);
            switch (contractDefinition.srcWasmLang) {
                case 'rust': {
                    const wasmInstanceExports = {
                        exports: null,
                        modifiedExports: {
                            wasm_bindgen__convert__closures__invoke2_mut__: null,
                            _dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__: null
                        }
                    };
                    /**
                     * wasm-bindgen mangles import function names (adds some random number after "base name")
                     * - that's why we cannot statically build the imports in the SDK.
                     * Instead - we need to first compile the module and check the generated
                     * import function names (all imports from the "__wbindgen_placeholder__" import module).
                     * Having those generated function names - we need to then map them to import functions -
                     * see {@link rustWasmImports}
                     *
                     * That's probably a temporary solution - it would be the best to force the wasm-bindgen
                     * to NOT mangle the import function names - unfortunately that is not currently possible
                     * - https://github.com/rustwasm/wasm-bindgen/issues/1128
                     */
                    const wasmModule = await getWasmModule(wasmResponse, contractDefinition.srcBinary);
                    const moduleImports = WebAssembly.Module.imports(wasmModule);
                    const wbindgenImports = moduleImports
                        .filter((imp) => {
                        return imp.module === '__wbindgen_placeholder__';
                    })
                        .map((imp) => imp.name);
                    const { imports, exports } = (0, rust_wasm_imports_1.rustWasmImports)(swGlobal, wbindgenImports, wasmInstanceExports, contractDefinition.metadata.dtor);
                    jsExports = exports;
                    wasmInstance = await WebAssembly.instantiate(wasmModule, imports);
                    wasmInstanceExports.exports = wasmInstance.exports;
                    const moduleExports = Object.keys(wasmInstance.exports);
                    // ... no comments ...
                    moduleExports.forEach((moduleExport) => {
                        if (moduleExport.startsWith('wasm_bindgen__convert__closures__invoke2_mut__')) {
                            wasmInstanceExports.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__ =
                                wasmInstance.exports[moduleExport];
                        }
                        if (moduleExport.startsWith('_dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__')) {
                            wasmInstanceExports.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__ =
                                wasmInstance.exports[moduleExport];
                        }
                    });
                    break;
                }
                default: {
                    throw new Error(`Support for ${contractDefinition.srcWasmLang} not implemented yet.`);
                }
            }
            this.logger.info(`WASM ${contractDefinition.srcWasmLang} handler created in ${benchmark.elapsed()}`);
            return new WasmHandlerApi_1.WasmHandlerApi(swGlobal, contractDefinition, jsExports || wasmInstance.exports);
        }
        else {
            const normalizedSource = (0, normalize_source_1.normalizeContractSource)(contractDefinition.src, evaluationOptions.useVM2);
            if (normalizedSource.includes('unsafeClient')) {
                switch (evaluationOptions.unsafeClient) {
                    case 'allow': {
                        this.logger.warn(`Reading unsafe contract ${contractDefinition.txId}, evaluation is non-deterministic!`);
                        break;
                    }
                    case 'throw':
                        throw new Error(`[SkipUnsafeError] Using unsafeClient is not allowed by default. Use EvaluationOptions.unsafeClient flag to evaluate ${contractDefinition.txId}.`);
                    case 'skip': {
                        throw new ContractError(`[SkipUnsafeError] Skipping evaluation of the unsafe contract ${contractDefinition.txId}.`, 'unsafeClientSkip');
                    }
                    default:
                        throw new Error(`Unknown unsafeClient setting ${evaluationOptions.unsafeClient}`);
                }
            }
            if (!evaluationOptions.allowBigInt) {
                if (normalizedSource.includes('BigInt')) {
                    throw new Error('Using BigInt is not allowed by default. Use EvaluationOptions.allowBigInt flag.');
                }
            }
            if (evaluationOptions.useVM2) {
                const vmScript = new vm2.VMScript(normalizedSource);
                const typedArrays = {
                    Int8Array: Int8Array,
                    Uint8Array: Uint8Array,
                    Uint8ClampedArray: Uint8ClampedArray,
                    Int16Array: Int16Array,
                    Uint16Array: Uint16Array,
                    Int32Array: Int32Array,
                    Uint32Array: Uint32Array,
                    Float32Array: Float32Array,
                    Float64Array: Float64Array,
                    BigInt64Array: BigInt64Array,
                    BigUint64Array: BigUint64Array
                };
                const vm = new vm2.NodeVM({
                    console: 'off',
                    sandbox: {
                        SmartWeave: swGlobal,
                        BigNumber: BigNumber,
                        logger: this.logger,
                        ContractError: ContractError,
                        ContractAssert: function (cond, message) {
                            if (!cond)
                                throw new ContractError(message);
                        },
                        //https://github.com/patriksimek/vm2/issues/484#issuecomment-1327479592
                        ...typedArrays
                    },
                    compiler: 'javascript',
                    eval: false,
                    wasm: false,
                    allowAsync: true,
                    wrapper: 'commonjs'
                });
                return new JsHandlerApi_1.JsHandlerApi(swGlobal, contractDefinition, vm.run(vmScript));
            }
            else if (warp.hasPlugin('ivm-handler-api')) {
                const ivmPlugin = warp.loadPlugin('ivm-handler-api');
                return ivmPlugin.process({
                    contractSource: contractDefinition.src,
                    evaluationOptions,
                    arweave: this.arweave,
                    swGlobal: swGlobal,
                    contractDefinition
                });
            }
            else {
                const contractFunction = new Function(normalizedSource);
                const handler = (0, utils_1.isBrowser)()
                    ? contractFunction(swGlobal, BigNumber, LoggerFactory_1.LoggerFactory.INST.create(swGlobal.contract.id), warp_isomorphic_1.Buffer, atob, btoa)
                    : contractFunction(swGlobal, BigNumber, LoggerFactory_1.LoggerFactory.INST.create(swGlobal.contract.id));
                return new JsHandlerApi_1.JsHandlerApi(swGlobal, contractDefinition, handler);
            }
        }
    }
}
exports.HandlerExecutorFactory = HandlerExecutorFactory;
function generateResponse(wasmBinary) {
    const init = { status: 200, statusText: 'OK', headers: { 'Content-Type': 'application/wasm' } };
    return new Response(wasmBinary, init);
}
async function getWasmModule(wasmResponse, binary) {
    if (WebAssembly.compileStreaming) {
        return await WebAssembly.compileStreaming(wasmResponse);
    }
    else {
        return await WebAssembly.compile(binary);
    }
}
//# sourceMappingURL=HandlerExecutorFactory.js.map